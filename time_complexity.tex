\section{Time complexity $subsums_{\mathrm{graph star}}$ algorithm}


\input{algorithm/subsums_q_star}

We aim to prove that the algorithm $subsums_{\mathrm{graph star}}$ terminates in polynomial time and, more precisely, that its time complexity is
\begin{equation}
O(n_{Q_{sunion}} \times n_{tp}),
\end{equation}
where $n_{Q_{sunion}}$ is the number of union branches in the query $Q_s$ and $n_{tp}$ is the total number of triple patterns in the input graph star pattern $Q_{starT_i}$.

\paragraph{Preliminaries}
We assume that the \texttt{match} function operates in constant time, returning \texttt{true} if two triple patterns are structurally identical, regardless of variable names.

\paragraph{Worst-case per $Q_{star}$}
Let $n_{qstar}$ denote the number of distinct $Q_{star} \in Q_{starT_i}$.
For each node $Q_{star}$, the algorithm iterates over its triple patterns, resulting in a time complexity of $O(n_{tp_{Q_{star}}})$.
For each triple pattern that does not match the shape body ($Q_{s\mathrm{body}}$), the algorithm iterates over all union branches in $Q_{sunion}$, making at most $n_{Q_{sunion}}$ recursive calls.
Each $q_{us} \in Q_{sunion}$ cannot contain a Union Graph Pattern (UGP), and is therefore always of the form $Q_s = Q_{s\mathrm{body}}$.
After the first execution, the worst-case scenario becomes one in which the triple patterns matches a pattern in $Q_{s\mathrm{body}}$, and the condition $O(tp) \in S_{star}(Q_{starT_i})$ holds.
In such cases, the algorithm recursively explores the corresponding partial Graph Star Pattern (GSP) by executing $subsums_{\mathrm{graph star}}$, following a graph traversal paradigm.


\paragraph{Tree Traversal Argument}
Although $Q_{starT_i}$ is a graph, the algorithm avoids cycles due to "caching", once a node $Q_{star}$ is evaluated, its result is stored in $Eval_{star}$.
Therefore, each node is visited at most once, and the overall traversal is equivalent to a tree traversal of size $n_{qstar} \leq |Q_{starT_i}|$.

\paragraph{Total Complexity}
Let $n_{tp_{Q_{star}}}$ denote the number of triple patterns in a particular $Q_{star}$, and let $n_{tp}$ be the total number of triple patterns across all nodes, so
$$
n_{tp} = \sum_{Q_{star} \in Q_{starT_i}} n_{tp_{Q_{star}}}
$$

Then the total number of recursive operations over all nodes is bounded by:
$$
\sum_{i=1}^{n_{qstar}} n_{Q_{sunion}} \times n_{tp_{Q_{star_i}}} = n_{Q_{sunion}} \times \sum_{i=1}^{n_{qstar}} n_{tp_{Q_{star_i}}} = O(n_{Q_{sunion}} \times n_{tp})
$$

The time complexity can alternatively be expressed as
\begin{equation}
O(n_{Q_{sunion}} \times n_{tp_{Q_{star_{max}}}}),
\end{equation}
where $n_{tp_{Q_{star_{max}}}}$ denotes the maximum number of triple patterns in any $Q_{star}$ node in the worst-case execution scenario.

\section{Time Complexity of the $subsums_{\mathrm{Q}}$ Algorithm}

\input{algorithm/subsums_Q}

The time complexity of the $subsums_{\mathrm{Q}}$ algorithm is straightforward to derive, as it consists of iterating over the Graph Pattern Structures (GPS) of the query and applying the $subsums_{\mathrm{graph star}}$ algorithm. Thus, the time complexity is given by:
\begin{equation}
O(n_{Q_{sunion}} \times n_{tp_{max}} \times n_{Q_{star_{max}}} \times n_{Q_{starG}}),
\end{equation}

Where, $n_{tp_{max}}$ is the maximum number of triple patterns in any $Q_{starG}$,
$n_{Q_{star_{max}}}$ is the maximum number of $Q_{star}$ patterns in any $Q_{starG}$,
$n_{Q_{starG}}$ is the number of Graph Pattern Structures (GPS) in the query $Q$.\footnote{
    Sharing the evaluation results $Eval_{star}$ from $subsums_{\mathrm{graph\ star}}$ could reduce execution time and potentially the algorithm's complexity.
}
